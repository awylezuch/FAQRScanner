<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QR-Scanner (stabiler Switch, Front default)</title>
<style>
  :root { --accent:#0078d7; }
  html,body{margin:0;padding:0;height:100%;background:#000;color:#fff;font-family:system-ui,"Segoe UI",Roboto,Arial,sans-serif;overflow:hidden}
  #scanner-container{position:relative;width:100vw;height:100vh;overflow:hidden;background:#000}
  #preview{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;background:#000;z-index:0}

  .darken{position:absolute;inset:0;background:rgba(0,0,0,.35);z-index:1;pointer-events:none}
  .clear-window{position:absolute;top:30%;left:20%;width:60%;height:40%;
    border:3px solid var(--accent);border-radius:8px;background:transparent;z-index:2;pointer-events:none;
    box-shadow:0 0 0 9999px rgba(0,0,0,.22)}
  .scanline{position:absolute;left:20%;width:60%;height:2px;background:rgba(0,120,215,.95);
    border-radius:1px;animation:scanAnim 2s linear infinite;z-index:3;pointer-events:none}
  @keyframes scanAnim{0%{top:30%}50%{top:70%}100%{top:30%}}

  /* Controls OBEN fixiert */
  .controls{
    position:fixed;
    top:calc(env(safe-area-inset-top, 0px) + 10px);
    left:50%; transform:translateX(-50%);
    display:flex; gap:10px; z-index:10000;
    align-items:center; flex-wrap:wrap; justify-content:center; max-width:92vw;
  }
  button{appearance:none;border:none;border-radius:8px;padding:10px 14px;font-size:15px;cursor:pointer;background:var(--accent);color:#fff}
  button.secondary{background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.25)}
  #status{position:fixed;left:12px;right:12px;top:calc(env(safe-area-inset-top, 0px) + 56px);
    z-index:10000;font-size:13px;line-height:1.25;color:#eee;text-shadow:0 1px 2px rgba(0,0,0,.8);
    max-height:25vh;overflow:auto;padding:6px 8px;background:rgba(0,0,0,.35);border-radius:6px}
</style>
</head>
<body>
  <div id="scanner-container">
    <video id="preview" autoplay playsinline muted></video>

    <div class="darken"></div>
    <div class="clear-window" aria-hidden="true"></div>
    <div class="scanline" aria-hidden="true"></div>

    <div id="status">Initialisiere…</div>

    <div class="controls">
      <button id="switchCamera" class="secondary" type="button">Kamera wechseln</button>
      <button id="rescan" class="secondary" type="button" style="display:none;">Nochmal scannen</button>
    </div>
  </div>

  <!-- Libs -->
  <script src="https://unpkg.com/@zxing/library@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr/dist/jsQR.js"></script>

  <script>
    const videoEl   = document.getElementById('preview');
    const statusEl  = document.getElementById('status');
    const switchBtn = document.getElementById('switchCamera');
    const rescanBtn = document.getElementById('rescan');

    const FALLBACK_DELAY_MS = 8000; // Fallback später
    const RELEASE_WAIT_MS   = 300;  // kurze Pause beim Switch
    const RETRY_ON_BUSY_MS  = 600;  // Retry bei NotReadableError

    // Canvas für Fallback (jsQR)
    const canvas = document.createElement('canvas');
    const ctx    = canvas.getContext('2d');

    // Geräte-IDs
    let devices = [];
    let frontId = null;
    let backId  = null;
    let currentDeviceId = null;

    // Zustände
    let scanning = false;
    let fallbackActive = false;
    let lastHit = 0;
    let switching = false; // Reentrancy Lock

    // ZXing Reader (eine Instanz)
    const reader = new ZXing.BrowserQRCodeReader();

    function log(msg){ console.log(msg); statusEl.textContent = typeof msg==='string'? msg : JSON.stringify(msg); }

    function stopCamera(){
      try { reader.reset(); } catch(e){}
      const s = videoEl.srcObject;
      if (s && s.getTracks){ s.getTracks().forEach(t=>t.stop()); }
      videoEl.srcObject = null;
      currentDeviceId = null;
    }

    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    async function ensurePermission(){
      try{
        log('Berechtigung anfordern…');
        const tmp = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
        tmp.getTracks().forEach(t=>t.stop());
        log('Berechtigung OK.');
        return true;
      }catch(e){
        log(`getUserMedia-Fehler: ${e.name} – ${e.message}`);
        return false;
      }
    }

    async function loadDevices(){
      devices = await ZXing.BrowserQRCodeReader.listVideoInputDevices();
      // Heuristik: anhand Label Front/Back bestimmen
      const find = (rx)=> devices.find(d => rx.test((d.label||'').toLowerCase()))?.deviceId || null;
      frontId = find(/front|user/);
      backId  = find(/back|rear|environment/);
      if (!frontId && devices[0]) frontId = devices[0].deviceId;
      if (!backId  && devices[1]) backId  = devices[1].deviceId || frontId;
      log(`Kameras gefunden: ${devices.length} | Front=${!!frontId} Back=${!!backId}`);
    }

    function getScanRect(){
      const vw = videoEl.videoWidth  || 1280;
      const vh = videoEl.videoHeight || 720;
      const sw = Math.floor(vw * 0.60);
      const sh = Math.floor(vh * 0.40);
      const sx = Math.floor((vw - sw) / 2);
      const sy = Math.floor((vh - sh) / 2);
      return { sx, sy, sw, sh };
    }

    // >> Weiterleitung mit bereits ermitteltem 'extracted'
    function navigateToBC(extracted){
      const url =
        "https://bcprod01.schwegler.de/BCProd/" +
        "?page=99000831" +
        "&company=Schwegler%20Werkzeugfabrik" +
        "&dc=0" +
        "&filter=%27No.%27%20IS%20%27" + encodeURIComponent(extracted) + "%27";
      window.location.href = url;
    }

    // Dekodier-Ergebnis behandeln – hier NUR den bereits ermittelten Wert verwenden
    function onDecode(extracted){
      if (!scanning) return;
      scanning = false;
      fallbackActive = false;
      rescanBtn.style.display = 'inline-block';
      log(`QR erkannt: ${extracted}`);
      navigateToBC(extracted);
    }

    // Aus dem rohen Text den gewünschten Wert extrahieren
    function extractValue(txt){
      // Regeln:
      // - $FA…..$  -> FA… (ohne $)
      // - FA…..$…  -> Teil vor dem ersten $
      // - andernfalls: kompletter Text
      let m = txt.match(/\$(FA[^$]+)\$/);
      if (m && m[1]) return m[1];
      m = txt.match(/^(FA[^$]+)/);
      if (m && m[1]) return m[1];
      return txt;
    }

    async function startWithDeviceId(deviceId, attempt=0){
      if (switching) return;
      switching = true;
      try{
        // Alles sauber schließen
        stopCamera();
        await sleep(RELEASE_WAIT_MS); // kurze Pause, bis Hardware frei ist

        const constraints = {
          video: {
            deviceId: { exact: deviceId },
            width: { ideal: 1920 }, height: { ideal: 1080 },
            advanced: [{ focusMode: "continuous" }]
          },
          audio: false
        };

        // Sichtbares Video
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoEl.srcObject = stream;
        await videoEl.play().catch(()=>{});

        // ZXing kontinuierlich
        reader.reset();
        reader.decodeFromVideoDevice(deviceId, 'preview', (result, err) => {
          if (!scanning) return;
          if (result){
            lastHit = Date.now();
            const txt = result.text || '';
            const extracted = extractValue(txt);
            onDecode(extracted);
          }
          // err während des kontinuierlichen Scans ignorieren
        });

        currentDeviceId = deviceId;
        scanning = true;
        fallbackActive = false;
        lastHit = Date.now();
        log(`Scanner läuft (ZXing) – Device ${deviceId.substring(0,6)}…`);

        // Fallback erst später
        setTimeout(()=> {
          if (scanning && Date.now() - lastHit > (FALLBACK_DELAY_MS - 500) && !fallbackActive) {
            log('Kein Treffer mit ZXing – Fallback aktiv (jsQR)…');
            startFallbackLoop();
          }
        }, FALLBACK_DELAY_MS);

      }catch(e){
        log(`Start-Fehler: ${e.name} – ${e.message}`);
        // NotReadableError = Quelle noch belegt → kurzen Retry
        if (e.name === 'NotReadableError' && attempt < 3){
          await sleep(RETRY_ON_BUSY_MS);
          await startWithDeviceId(deviceId, attempt+1);
        }
      } finally {
        switching = false;
      }
    }

    function startFallbackLoop(){
      fallbackActive = true;
      const tick = () => {
        if (!scanning || !fallbackActive) return;
        const vw = videoEl.videoWidth, vh = videoEl.videoHeight;
        if (vw && vh){
          const { sx, sy, sw, sh } = getScanRect();
          canvas.width = sw; canvas.height = sh;
          try{
            ctx.drawImage(videoEl, sx, sy, sw, sh, 0, 0, sw, sh);
            const imageData = ctx.getImageData(0, 0, sw, sh);
            const code = jsQR(imageData.data, sw, sh, { inversionAttempts: "attemptBoth" });
            if (code && code.data){
              const extracted = extractValue(code.data);
              onDecode(extracted);
              return;
            }
          }catch(e){ /* ignorieren */ }
        }
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }

    async function autoStart(){
      const ok = await ensurePermission();
      if (!ok) return;
      await loadDevices();
      // Front bevorzugen
      const first = frontId || backId || (devices[0] && devices[0].deviceId);
      if (!first){ log('Keine Kamera verfügbar.'); return; }
      await startWithDeviceId(first);
    }

    // UI
    switchBtn.addEventListener('click', async ()=>{
      if (!devices.length){ await loadDevices(); }
      const target = (currentDeviceId === frontId && backId) ? backId
                   : (currentDeviceId === backId  && frontId) ? frontId
                   : (currentDeviceId !== frontId && frontId) ? frontId
                   : backId || frontId || (devices[0] && devices[0].deviceId);
      rescanBtn.style.display = 'none';
      scanning = true; fallbackActive = false;
      await startWithDeviceId(target);
    });

    rescanBtn.addEventListener('click', async ()=>{
      rescanBtn.style.display = 'none';
      scanning = true; fallbackActive = false;
      if (!currentDeviceId){
        await autoStart();
      } else {
        await startWithDeviceId(currentDeviceId);
      }
    });

    window.addEventListener('load', autoStart);

    document.addEventListener('visibilitychange', ()=>{
      if (document.visibilityState === 'visible' && videoEl.srcObject && videoEl.paused){
        videoEl.play().catch(()=>{});
      }
    });
  </script>
</body>
</html>
